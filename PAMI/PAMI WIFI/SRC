// Inclusion des bibliothèques
#include <Arduino.h>
#include <WiFi.h>
#include <WebServer.h>
#include <ESP32servo.h>

// Definition du paramètre de temps de connection
#define CONNECTION_TIMEOUT 10

// Définition des logins
const char* ssid = "Samsung de sacha"; // SERVICE SET IDENTIFIER (adresse humaine du réseau)
const char* password = "combaret";

// Définitions des broches pour le Moteur 1
// EN A doit être connecté à une broche PWM (Pulse Width Modulation) pour contrôler la vitesse
const int EN_A = 25; // Broche GPIO 25 (PWM pour la vitesse)
const int IN1 = 26;  // Broche GPIO 26 (Sens de rotation)
const int IN2 = 27;  // Broche GPIO 27 (Sens de rotation)

// Définitions des broches pour le Moteur 2
const int EN_B = 14; // Broche GPIO 14 (PWM pour la vitesse)
const int IN3 = 12;  // Broche GPIO 12 (Sens de rotation)
const int IN4 = 13;  // Broche GPIO 13 (Sens de rotation)

// Paramètres de la PWM (Pulse Width Modulation) pour l'ESP32
// Nous allons utiliser deux canaux PWM différents pour les deux moteurs
const int freq = 5000;      // Fréquence en Hz
const int resolution = 8;   // Résolution de 8 bits (0-255)
const int ledChannel_A = 0; // Canal PWM 0 pour le Moteur 1
const int ledChannel_B = 1; // Canal PWM 1 pour le Moteur 2

// Définitions du Servomoteur et de sa broche output
const int PIN_SG90 = 23;
Servo SG90;

// Définitions des broches et des variables pour le Doppler
const int TRIG = 22;
const int ECHO = 21;
const int sound_speed = 340;
const int trig_pulse_duration_us = 10;
long ultrason_duration;
float distance_cm;

// Définition du webserveur
WebServer server(80);

/**
 * @brief Fonction pour afficher les caractéristiques du réseau
 */
void info_wifi(){
  // boucle pour vérifier la connexion avant d'afficher
  if (WiFi.status() == WL_CONNECTED){
    Serial.print("Information pour le réseau en tant que ");
    Serial.println(ssid); // nom du réseau
    Serial.println("[+] BSSID : " + WiFi.BSSIDstr()); // BASIC SERVICE SET IDENTIFIER (adresse physique du point d'accès(adresse codant en dur dans le routeur))
    Serial.print("[+] Gateway IP : ");
    Serial.println(WiFi.gatewayIP()); // adresse IP du routeur/passerelle
    Serial.print("[+] Subnet Mask : ");
    Serial.println(WiFi.subnetMask()); // masque de sous-réseau(définit quelle partie d'une adresse IP identifie le réseau et quelle partie identifie l'hôte)
    Serial.println((String)"[+] RSSI : " + WiFi.RSSI() + " dB"); // RECEIVED SIGNAL STRENGTH INDICATOR (Indicateur de force du signal reçu)
    Serial.print("[+] ESP32 IP : "); 
    Serial.println(WiFi.localIP()); // adresse IP correspondant a l'ESP32
  }
}

/**
 * @brief Fonction pour créer le site internet
 */
void handleRoot() {
  // Creation de la chaine de charactère avec le code HTML pour la page
  const char html[] PROGMEM = R"rawliteral(
  <!DOCTYPE HTML><html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="icon" href="data:,">
    <style>
      html { font-family: Helvetica; display: inline-block; margin: 0px auto; text-align: center; }
      .button { -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; background-color: #4CAF50; border: none; color: white; padding: 12px 28px; text-decoration: none; font-size: 26px; margin: 1px; cursor: pointer; }
      .button2 {background-color: #FF0000;}
      .button3 { background-color: #008CBA; font-size: 20px; padding: 12px 28px; }
    </style>
    <script>
      function deplacerAvant() { fetch('/avant'); }
      function tournerGauche() { fetch('/gauche'); }
      function arreterRobot() { fetch('/stop'); } 
      function tournerDroite() { fetch('/droite'); }
      function deplacerArriere() { fetch('/arriere'); }
      function servoMoteur() { fetch('/servo'); }
      function basculerServo() { fetch('/servo'); 
        let bouton = document.getElementById('boutonServo');
        if (bouton.innerHTML === "SERVOMOTEUR : OFF") {
          bouton.innerHTML = "SERVOMOTEUR : ON";
        } else {
          bouton.innerHTML = "SERVOMOTEUR : OFF";
        }
      }
      function getDistance() {
        fetch('/distance')
          .then(response => response.text())
          .then(text => {
            document.getElementById('distanceMesuree').innerHTML = text;
          });
      }
      setInterval(getDistance, 500);
    </script>
  </head>
  <body>
    <h1>Controle de Moteur</h1>
    <p><button class="button" onclick="deplacerAvant()">AVANCER</button></p>
    <div style="clear: both;">
      <p>
        <button class="button" onclick="tournerGauche()">GAUCHE</button>
        <button class="button button2" onclick="arreterRobot()">STOP</button>
        <button class="button" onclick="tournerDroite()">DROITE</button>
      </p>
    </div>
    <p><button class="button" onclick="deplacerArriere()">RECULER</button></p>
    <h2>Controle du Servomoteur</h2>
    <p><button class="button button3" id="boutonServo" onclick="basculerServo()">SERVOMOTEUR : OFF</button>
    <h2>Distance : <span id="distanceMesuree">--</span> cm</h2>
    </body>
  </html>)rawliteral";
  // Envoie du code au navigateur web
  server.send(200, "text/html", html);
}

/**
 * @brief Fonction pour faire avancer le PAMI
 */
void handleForward() {
  digitalWrite(IN1, LOW);
  digitalWrite(IN2, HIGH); 
  digitalWrite(IN3, LOW);
  digitalWrite(IN4, HIGH);
  server.send(200);
}

/**
 * @brief Fonction pour faire tourner sur la gauche le PAMI
 */
void handleLeft() {
  digitalWrite(IN1, LOW); 
  digitalWrite(IN2, LOW); 
  digitalWrite(IN3, LOW);
  digitalWrite(IN4, HIGH);
  server.send(200);
}

/**
 * @brief Fonction pour faire arréter le PAMI
 */
void handleStop() {
  digitalWrite(IN1, LOW); 
  digitalWrite(IN2, LOW); 
  digitalWrite(IN3, LOW);
  digitalWrite(IN4, LOW);   
  server.send(200);
}

/**
 * @brief Fonction pour faire tourner sur la droite le PAMI
 */
void handleRight() {
  digitalWrite(IN1, LOW); 
  digitalWrite(IN2, HIGH); 
  digitalWrite(IN3, LOW);
  digitalWrite(IN4, LOW);    
  server.send(200);
}

/**
 * @brief Fonction pour faire reculer le PAMI
 */
void handleReverse() {
  digitalWrite(IN1, HIGH);
  digitalWrite(IN2, LOW); 
  digitalWrite(IN3, HIGH);
  digitalWrite(IN4, LOW);          
  server.send(200);
}

/**
 * @brief Fonction pour controler le Servomoteur
 */
void handleServo(){
  //rotation de 0 to 180°
  for (int pos = 0; pos <= 180; pos += 1) {
    SG90.write(pos);
    delay(10);
  }
  // Rotation de 180° to 0
  for (int pos = 180; pos >= 0; pos -= 1) {
    SG90.write(pos);
    delay(10);
  }
}

/**
 * @brief Calcul la distance devant le PAMI grâce au Doppler
 */
void handleDistance() {
  // Set up le signal
  digitalWrite(TRIG, LOW);
  delayMicroseconds(2);
  // Crée une impulsion de 10 µs
  digitalWrite(TRIG, HIGH);
  delayMicroseconds(trig_pulse_duration_us);
  digitalWrite(TRIG, LOW);
  // Retourne le temps de propagation
  ultrason_duration = pulseIn(ECHO, HIGH);
  // Calcul la distance (en cm)
  distance_cm = ultrason_duration * sound_speed/2 * 0.0001;
  // Ecrit la distance dans l'interface
  String distance_str = String(distance_cm);
  server.send(200,"text/plain",distance_str);
  delay(1000);
}

/**
 * @brief Fonction pour tout mettre en place
 */
void setup(){
  // Lancement de l'interface série
  Serial.begin(112500);
  delay(1000);

  // Configuration des moteurs
  Serial.println("Initialisation du controle du PAMI...");
  // --- Configuration du Moteur 1 ---
  // Configure les broches en mode sortie
  pinMode(IN1, OUTPUT);
  pinMode(IN2, OUTPUT);
  // EN_A est géré par le PWM (ledcSetup et ledcAttachPin)
  // Configuration du canal PWM 0 pour le Moteur 1 (Vitesse)
  ledcSetup(ledChannel_A, freq, resolution);
  ledcAttachPin(EN_A, ledChannel_A);

  // --- Configuration du Moteur 2 ---
  pinMode(IN3, OUTPUT);
  pinMode(IN4, OUTPUT);
  // EN_B est géré par le PWM
  // Configuration du canal PWM 1 pour le Moteur 2 (Vitesse)
  ledcSetup(ledChannel_B, freq, resolution);
  ledcAttachPin(EN_B, ledChannel_B);

  // Configuration du Servomoteur
  SG90.setPeriodHertz(50); // fréquence du PWM pour le servomoteur
  SG90.attach(PIN_SG90, 500, 2400); // Calibre les largeurs d'impulsion (en µs) minimum et maximum du PWM pour faire tourner le servomoteur de 0° et de 180°

  // Configuration du Doppler
  pinMode(TRIG, OUTPUT); // Configure la broche TRIG en mode sortie
  pinMode(ECHO, INPUT); // Configure la broche ECHO en mode entrée

  Serial.println("Pret a faire fonctionner le PAMI.");

  // Connexion au wifi
  WiFi.begin(ssid,password);
  Serial.println("\nConnecting...");
  int timeout_counter = 0;

  // Boucle pour s'assurer que le wifi est bien connecté
  while (WiFi.status() != WL_CONNECTED){
    Serial.print(".");
    delay(100);
    timeout_counter++;
    if (timeout_counter >= CONNECTION_TIMEOUT*5){
      ESP.restart();
    }
  }

  // Annonce de la connexion
  Serial.println("\nConnecté au wifi");

  // Affiche les caractéristique du réseau
  info_wifi();

  // Definir les intéractions avec le site
  server.on("/", handleRoot);
  server.on("/avant", handleForward);
  server.on("/gauche", handleLeft);
  server.on("/stop", handleStop);
  server.on("/droite", handleRight);
  server.on("/arriere", handleReverse);
  server.on("/servo", handleServo);
  server.on("/distance", handleDistance);

  // Démarre le serveur
  server.begin();
}

/**
 * @brief Fonction où réaliser l'action souhaité
 */
void loop(){
  server.handleClient();
}
